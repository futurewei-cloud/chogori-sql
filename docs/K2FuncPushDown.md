# PG built-in functions

## a) Pg built-in functions are defined by PG code
For example, int.c, Functions for the built-in integer types (except int8).

``` c
Datum
int4pl(PG_FUNCTION_ARGS)
{
	int32		arg1 = PG_GETARG_INT32(0);
	int32		arg2 = PG_GETARG_INT32(1);
	int32		result;

	if (unlikely(pg_add_s32_overflow(arg1, arg2, &result)))
		ereport(ERROR,
				(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),
				 errmsg("integer out of range")));
	PG_RETURN_INT32(result);
}
```

## b) fmgr.h/.c - PG function manager and function-call interface

PG function signature
``` c
typedef Datum (*PGFunction) (FunctionCallInfo fcinfo);
```

## c) fmgrtab.h/.c - table of internal functions

The file is generated by src/backend/utils/Gen_fmgrtab.pl during build process

```
FMGR_DATA := $(addprefix $(top_srcdir)/src/include/catalog/,\
	pg_language.dat pg_proc.dat \
	)

# fmgr-stamp records the last time we ran Gen_fmgrtab.pl.  We don't rely on
# the timestamps of the individual output files, because the Perl script
# won't update them if they didn't change (to avoid unnecessary recompiles).
fmgr-stamp: Gen_fmgrtab.pl $(catalogdir)/Catalog.pm $(FMGR_DATA) $(top_srcdir)/src/include/access/transam.h
	$(PERL) -I $(catalogdir) $< -I $(top_srcdir)/src/include/ $(FMGR_DATA)
	touch $@
```

The generated fmgrtab.c holds the list of built-in functions

``` c
const FmgrBuiltin fmgr_builtins[] = {
  { 31, "byteaout", 1, true, false, byteaout },
  { 33, "charout", 1, true, false, charout },
  { 34, "namein", 1, true, false, namein },
  { 35, "nameout", 1, true, false, nameout },
…
  { 176, "int2pl", 2, true, false, int2pl },
  { 177, "int4pl", 2, true, false, int4pl },
  { 178, "int24pl", 2, true, false, int24pl },
  { 179, "int42pl", 2, true, false, int42pl },
…
  { 6119, "pg_get_publication_tables", 1, true, true, pg_get_publication_tables },
  { 6120, "pg_get_replica_identity_index", 1, true, false, pg_get_replica_identity_index },
  { 6121, "pg_relation_is_publishable", 1, true, false, pg_relation_is_publishable },
  { 9901, "ybcinhandler", 1, true, false, ybcinhandler }
};
```
Where FmgrBuiltin was defined as

``` c
typedef struct
{
	Oid			foid;			/* OID of the function */
	const char *funcName;		/* C name of the function */
	short		nargs;			/* 0..FUNC_MAX_ARGS, or -1 if variable count */
	bool		strict;			/* T if function is "strict" */
	bool		retset;			/* T if function returns a set */
	PGFunction	func;			/* pointer to compiled function */
} FmgrBuiltin;
```
## d) fmgr could look up and check the built-in function based on the above table

``` c
/*
 * Lookup a builtin by name.  Note there can be more than one entry in
 * the array with the same name, but they should all point to the same
 * routine.
 */
static const FmgrBuiltin *
fmgr_lookupByName(const char *name)
{
	int			i;

	for (i = 0; i < fmgr_nbuiltins; i++)
	{
		if (strcmp(name, fmgr_builtins[i].funcName) == 0)
			return fmgr_builtins + i;
	}
	return NULL;
}

bool
is_builtin_func(Oid id)
{
	return fmgr_isbuiltin(id) != NULL;
}
```

# Function pushdown

## a) A list was introduced into the Query Plan Node: ModifyTable

``` c
typedef struct ModifyTable
{
	Plan		plan;
	CmdType		operation;		/* INSERT, UPDATE, or DELETE */
	bool		canSetTag;		/* do we set the command tag/es_processed? */
	Index		nominalRelation;	/* Parent RT index for use of EXPLAIN */
	/* RT indexes of non-leaf tables in a partition tree */
	List	   *partitioned_rels;
	bool		partColsUpdated;	/* some part key in hierarchy updated */
	List	   *resultRelations;	/* integer list of RT indexes */
	int			resultRelIndex; /* index of first resultRel in plan's list */
	int			rootResultRelIndex; /* index of the partitioned table root */
	List	   *plans;			/* plan(s) producing source data */
	List	   *withCheckOptionLists;	/* per-target-table WCO lists */
	List	   *returningLists; /* per-target-table RETURNING tlists */
	List	   *fdwPrivLists;	/* per-target-table FDW private data lists */
	Bitmapset  *fdwDirectModifyPlans;	/* indices of FDW DM plans */
	List	   *rowMarks;		/* PlanRowMarks (non-locking only) */
	int			epqParam;		/* ID of Param for EvalPlanQual re-eval */
	OnConflictAction onConflictAction;	/* ON CONFLICT action */
	List	   *arbiterIndexes; /* List of ON CONFLICT arbiter index OIDs  */
	List	   *onConflictSet;	/* SET for INSERT ON CONFLICT DO UPDATE */
	Node	   *onConflictWhere;	/* WHERE for ON CONFLICT UPDATE */
	Index		exclRelRTI;		/* RTI of the EXCLUDED pseudo relation */
	List	   *exclRelTlist;	/* tlist of the EXCLUDED pseudo relation */

	List	   *ybPushdownTlist; /* tlist for the pushed down SET expressions */
	bool	   no_index_update; /* planner has checked no indexes need update */
	bool	   no_row_trigger; /* planner has checked no triggers apply */
} ModifyTable;
```
When PG calls the following method to create the plan, the list ybPushdownTlist is generated

``` c
static ModifyTable *
create_modifytable_plan(PlannerInfo *root, ModifyTablePath *best_path);
```

, which calls the following method to pass the pushdown list in modify_tlist.

``` c
static bool
yb_single_row_update_or_delete_path(PlannerInfo *root,
									ModifyTablePath *path,
									List **result_tlist,
									List **modify_tlist,
									bool *no_index_update,
									bool *no_row_trigger);
```

Under the hood, the above method calls to analyze the plan subtree to check if the function is supported by YB’ DocDB or not.

``` c
static bool YBCAnalyzeExpression(Expr *expr, AttrNumber target_attnum, bool *has_vars, bool *has_docdb_unsupported_funcs)
{
  …
		case T_FuncExpr:
		case T_OpExpr:
		{
			List         *args = NULL;
			ListCell     *lc = NULL;
			Oid          funcid = InvalidOid;
			HeapTuple    tuple = NULL;

			/* Get the function info. */
			if (IsA(expr, FuncExpr))
			{
				FuncExpr *func_expr = castNode(FuncExpr, expr);
				args = func_expr->args;
				funcid = func_expr->funcid;
			}
			else if (IsA(expr, OpExpr))
			{
				OpExpr *op_expr = castNode(OpExpr, expr);
				args = op_expr->args;
				funcid = op_expr->opfuncid;
			}

			/*
			 * Only allow immutable functions as they cannot modify the
			 * database or do lookups.
			 */
			tuple = SearchSysCache1(PROCOID, ObjectIdGetDatum(funcid));
			if (!HeapTupleIsValid(tuple))
				elog(ERROR, "cache lookup failed for function %u", funcid);
			Form_pg_proc pg_proc = ((Form_pg_proc) GETSTRUCT(tuple));

			if (pg_proc->provolatile != PROVOLATILE_IMMUTABLE)
			{
				ReleaseSysCache(tuple);
				return false;
			}

			if (!YBCIsSupportedDocDBFunctionId(funcid, pg_proc)) {
				*has_docdb_unsupported_funcs = true;
			}
			ReleaseSysCache(tuple);

			/* Checking all arguments are valid (stable). */
			foreach (lc, args) {
				Expr* expr = (Expr *) lfirst(lc);
				if (!YBCAnalyzeExpression(expr, target_attnum, has_vars, has_docdb_unsupported_funcs)) {
				    return false;
				}
			}
			return true;
		}
…
}
```

YB supports almost all built-in functions except these that require catalog access because it linked with a PG c module, I.e., ybgate, directly.

``` c
/*
 * Check if the function/procedure can be executed by DocDB (i.e. if we can
 * pushdown its execution).
 * The main current limitation is that DocDB's execution layer does not have
 * syscatalog access (cache lookup) so only specific builtins are supported.q
 */
static bool YBCIsSupportedDocDBFunctionId(Oid funcid, Form_pg_proc pg_proc) {
	if (!is_builtin_func(funcid))
	{
		return false;
	}

	/*
	 * Polymorhipc pseduo-types (e.g. anyarray) may require additional
	 * processing (requiring syscatalog access) to fully resolve to a concrete
	 * type. Therefore they are not supported by DocDB.
	 */
	if (IsPolymorphicType(pg_proc->prorettype))
	{
		return false;
	}

	for (int i = 0; i < pg_proc->pronargs; i++)
	{
		if (IsPolymorphicType(pg_proc->proargtypes.values[i]))
		{
			return false;
		}
	}

	return true;
}
```

# Function Evaluation

## a) Pass the function
First, the YB logic created a PG operation expression and convert the function node into a string so that it passes it down to its DocDB

``` c
YBCPgExpr YBCNewEvalExprCall(YBCPgStatement ybc_stmt,
                             Expr *pg_expr,
                             YBExprParamDesc *params,
                             int num_params)
{
	YBCPgExpr ybc_expr = NULL;
	const YBCPgTypeEntity *type_ent = YBCDataTypeFromOidMod(InvalidAttrNumber, params[0].typid);
	YBCPgNewOperator(ybc_stmt, "eval_expr_call", type_ent, &ybc_expr);

	Datum expr_datum = CStringGetDatum(nodeToString(pg_expr));
	YBCPgExpr expr = YBCNewConstant(ybc_stmt, CSTRINGOID, expr_datum , /* IsNull */ false);
	YBCPgOperatorAppendArg(ybc_expr, expr);

	/*
	 * Adding the column type ids and mods to the message since we only have the YQL types in the
	 * DocDB Schema.
	 * TODO(mihnea): Eventually DocDB should know the full YSQL/PG types and we can remove this.
	 */
	for (int i = 0; i < num_params; i++) {
		Datum attno = Int32GetDatum(params[i].attno);
		YBCPgExpr attno_expr = YBCNewConstant(ybc_stmt, INT4OID, attno, /* IsNull */ false);
		YBCPgOperatorAppendArg(ybc_expr, attno_expr);

		Datum typid = Int32GetDatum(params[i].typid);
		YBCPgExpr typid_expr = YBCNewConstant(ybc_stmt, INT4OID, typid, /* IsNull */ false);
		YBCPgOperatorAppendArg(ybc_expr, typid_expr);

		Datum typmod = Int32GetDatum(params[i].typmod);
		YBCPgExpr typmod_expr = YBCNewConstant(ybc_stmt, INT4OID, typmod, /* IsNull */ false);
		YBCPgOperatorAppendArg(ybc_expr, typmod_expr);
	}
	return ybc_expr;
}
```

## b) Evaluate the function

Once YB’s DocDB receives the Pg operation expression, it converts the string value back to the expression tree and then evaluates it by walking the tree.

``` c
YbgStatus YbgEvalExpr(char* expr_cstring, YbgExprContext expr_ctx, uint64_t *datum, bool *is_null)
{
  PG_SETUP_ERROR_REPORTING();
  Expr *expr = (Expr *) stringToNode(expr_cstring);
  *datum = (uint64_t) evalExpr(expr_ctx, expr, is_null);
  return PG_STATUS_OK;
}
```

Where evalExpr is defined as

``` c
static Datum evalExpr(YbgExprContext ctx, Expr expr, bool *is_null)
{
  switch (expr->type)
  {
   case T_FuncExpr:
   case T_OpExpr:
   {
    Oid funcid = InvalidOid;
    List *args = NULL;
    ListCell *lc = NULL;

 	/* Get the (underlying) function info. */
 	if (IsA(expr, FuncExpr))
 	{
 		FuncExpr *func_expr = castNode(FuncExpr, expr);
 		args = func_expr->args;
 		funcid = func_expr->funcid;
 	}
 	else if (IsA(expr, OpExpr))
 	{
 		OpExpr *op_expr = castNode(OpExpr, expr);
 		args = op_expr->args;
 		funcid = op_expr->opfuncid;
 	}

 	FmgrInfo *flinfo = palloc0(sizeof(FmgrInfo));
 	FunctionCallInfo fcinfo = palloc0(SizeForFunctionCallInfo(args->length));

 	fmgr_info(funcid, flinfo);
 	InitFunctionCallInfoData(*fcinfo,
 	                         flinfo,
 	                         args->length,
 	                         InvalidOid,
 	                         NULL,
 	                         NULL);
 	int i = 0;
 	foreach(lc, args)
 	{
 		Expr *arg = (Expr *) lfirst(lc);
 		fcinfo->args[i].value = evalExpr(ctx, arg, &fcinfo->args[i].isnull);
 		/*
 		 * Strict functions are guaranteed to return NULL if any of
 		 * their arguments are NULL.
 		 */
 		if (flinfo->fn_strict && fcinfo->args[i].isnull) {
 			*is_null = true;
 			return (Datum) 0;
 		}
 		i++;
 	}
 	Datum result = **FunctionCallInvoke**(fcinfo);
 	*is_null = fcinfo->isnull;
 	return result;
 }
…

*is_null = true;
return (Datum) 0;
}
```

More details in https://github.com/futurewei-cloud/chogori-sql/issues/192

# K2 Function pushdown support

## a) we don’t want K2 platform depends on PG module directly, as a result, we removed the ybgate mode

https://github.com/futurewei-cloud/chogori-sql/issues/208

## b) we are going to disable the function pushdown temporarily and re-enable it once K2 platform supports it so that TPCC could run successfully without manual twist.

https://github.com/futurewei-cloud/chogori-sql/pull/215

Please be aware that disabling function pushdown significantly impacts the performance.
With function pushdown, the update statement  is a single update

```
postgres=# explain Update DISTRICT SET D_NEXT_O_ID = D_NEXT_O_ID + 1 WHERE D_W_ID = 1 AND D_ID = 2;
QUERY PLAN
Update on district (cost=0.00..4.12 rows=1 width=346)
-> Result (cost=0.00..4.12 rows=1 width=346)
```

However, it turns into a scan and then a update after disabling the function pushdown

```
postgres=# explain Update DISTRICT SET D_NEXT_O_ID = D_NEXT_O_ID + 1 WHERE D_W_ID = 1 AND D_ID = 2;
QUERY PLAN
Update on district (cost=0.00..4.12 rows=1 width=346)
-> Index Scan using district_pkey on district (cost=0.00..4.12 rows=1 width=346)
Index Cond: ((d_w_id = 1) AND (d_id = 2)
```

The above SQL comes with a secondary index, the performance could be much worse without the secondary index.

## d) To support function pushdown to K2 platform,
  ### 1) We need to add a new PG Gate API to provide a list of supported built-in functions from K2 Platform so that PG could know which function to pushdown during
Query Planning phase. This list could be cached at PG gate layer or inside PG. Be aware that the list should be PG built-in function name/id, not K2 function name/id. K2 adapter could
do the mapping.

        List GetK2SupportedFunction();

  ### 2) The current PG expression is enough to pass the function information down to K2 Platform, I.e., PgOperator with Opcode::PG_EXPR_EVAL_EXPR_CALL.
	then the first argument is a PgConstant to pass the function name or function oid, the other arguments are function arguments and they are PgConstants as well. No need to convert the function node
	into a string in our case.

	PgOperator ("eval_expr_call”)

                                     ------ PgConstant (function name/id)
                                     ------ PgConstant (function argument)


  ### 3) PG gate, i.e., K2 Adapter layer will map the PG built-in function name/id to the K2 function name/id and pass the arguments

  ### 4) K2 platform evals the k2 function by walking the expression tree and invoking the corresponding function similar to the logic in the following method
``` c
static Datum evalExpr(YbgExprContext ctx, Expr expr, bool *is_null)
```




