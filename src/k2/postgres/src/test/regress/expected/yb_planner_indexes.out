--------------------------------------
-- Hash-partitioned tables/indexes.
--------------------------------------
CREATE TABLE t1(h int, r int, v1 int, v2 int, v3 int, primary key(h HASH, r ASC));
CREATE INDEX t1_v1_v2_idx on t1(v1 HASH, v2 ASC);
CREATE UNIQUE INDEX t1_v3_uniq_idx on t1(v3 HASH);
--------------------------------------
-- Test unique vs non-unique indexes.
-- Expect to use t1_v3_uniq_idx because will guarantee a single-row scan (due to uniqueness).
EXPLAIN SELECT * FROM t1 WHERE v1 = 1 and v2 = 1 and v3 = 1;
                                QUERY PLAN
--------------------------------------------------------------------------
 Index Scan using t1_v3_uniq_idx on t1  (cost=0.00..4.13 rows=1 width=20)
   Index Cond: (v3 = 1)
   Filter: ((v1 = 1) AND (v2 = 1))
(3 rows)

-- Expect to use t1_v1_v2_idx because the inequality condition on v3 (HASH) is not useful.
EXPLAIN SELECT * FROM t1 WHERE v1 = 1 and v2 = 1 and v3 > 1;
                               QUERY PLAN
-------------------------------------------------------------------------
 Index Scan using t1_v1_v2_idx on t1  (cost=0.00..5.30 rows=10 width=20)
   Index Cond: ((v1 = 1) AND (v2 = 1))
   Filter: (v3 > 1)
(3 rows)

EXPLAIN SELECT * FROM t1 WHERE v1 = 1 and v2 > 1 and v3 > 1;
                               QUERY PLAN
-------------------------------------------------------------------------
 Index Scan using t1_v1_v2_idx on t1  (cost=0.00..5.30 rows=10 width=20)
   Index Cond: ((v1 = 1) AND (v2 > 1))
   Filter: (v3 > 1)
(3 rows)

--------------------------------------
-- Test covered vs uncovered indexes.
-- Should prioritize the pkey index because it covers all columns (index only scan).
EXPLAIN SELECT * FROM t1 WHERE h = 1 and v1 = 1;
                              QUERY PLAN
----------------------------------------------------------------------
 Index Scan using t1_pkey on t1  (cost=0.00..15.75 rows=100 width=20)
   Index Cond: (h = 1)
   Filter: (v1 = 1)
(3 rows)

EXPLAIN SELECT * FROM t1 WHERE h = 1 and r = 2 and v1 = 1 and v2 = 2;
                            QUERY PLAN
-------------------------------------------------------------------
 Index Scan using t1_pkey on t1  (cost=0.00..4.12 rows=1 width=20)
   Index Cond: ((h = 1) AND (r = 2))
   Filter: ((v1 = 1) AND (v2 = 2))
(3 rows)

-- Should prioritize the t1_v1_v2_idx because it is fully specified.
EXPLAIN SELECT * FROM t1 WHERE h = 1 and v1 = 1 and v2 = 2;
                               QUERY PLAN
-------------------------------------------------------------------------
 Index Scan using t1_v1_v2_idx on t1  (cost=0.00..5.30 rows=10 width=20)
   Index Cond: ((v1 = 1) AND (v2 = 2))
   Filter: (h = 1)
(3 rows)

--------------------------------------
-- Test partial indexes.
-- Should use t1_v1_v2_idx because conditions partly match.
EXPLAIN SELECT * FROM t1 WHERE v1 = 1 AND v3 > 1;
                                QUERY PLAN
---------------------------------------------------------------------------
 Index Scan using t1_v1_v2_idx on t1  (cost=0.00..16.75 rows=100 width=20)
   Index Cond: (v1 = 1)
   Filter: (v3 > 1)
(3 rows)

EXPLAIN SELECT * FROM t1 WHERE v1 = 1 AND v3 > 2;
                                QUERY PLAN
---------------------------------------------------------------------------
 Index Scan using t1_v1_v2_idx on t1  (cost=0.00..16.75 rows=100 width=20)
   Index Cond: (v1 = 1)
   Filter: (v3 > 2)
(3 rows)

EXPLAIN SELECT * FROM t1 WHERE v1 = 1 AND v3 > 3;
                                QUERY PLAN
---------------------------------------------------------------------------
 Index Scan using t1_v1_v2_idx on t1  (cost=0.00..16.75 rows=100 width=20)
   Index Cond: (v1 = 1)
   Filter: (v3 > 3)
(3 rows)

CREATE INDEX t1_v1_v2_uniq_partial_idx ON t1(v1, v2) WHERE v3 > 2;
-- Should still use t1_v1_v2_idx because partial index condition does not match.
EXPLAIN SELECT * FROM t1 WHERE v1 = 1 AND v3 > 1;
                                QUERY PLAN
---------------------------------------------------------------------------
 Index Scan using t1_v1_v2_idx on t1  (cost=0.00..16.75 rows=100 width=20)
   Index Cond: (v1 = 1)
   Filter: (v3 > 1)
(3 rows)

-- Should both use t1_v1_v2_uniq_partial_idx.
EXPLAIN SELECT * FROM t1 WHERE v1 = 1 AND v3 > 2;
                                       QUERY PLAN
----------------------------------------------------------------------------------------
 Index Scan using t1_v1_v2_uniq_partial_idx on t1  (cost=0.00..14.00 rows=100 width=20)
   Index Cond: (v1 = 1)
(2 rows)

EXPLAIN SELECT * FROM t1 WHERE v1 = 1 AND v3 > 3;
                                       QUERY PLAN
----------------------------------------------------------------------------------------
 Index Scan using t1_v1_v2_uniq_partial_idx on t1  (cost=0.00..14.20 rows=100 width=20)
   Index Cond: (v1 = 1)
   Filter: (v3 > 3)
(3 rows)

--------------------------------------
-- Range-partitioned tables/indexes.
--------------------------------------
CREATE TABLE t2(h int, r int, v1 int, v2 int, v3 int, primary key(h ASC, r ASC));
CREATE INDEX t2_v1_v2_idx on t2(v1 ASC, v2 ASC);
CREATE UNIQUE INDEX t2_v3_uniq_idx on t2(v3 ASC);
-- Expect to use t2_v3_uniq_idx because will guarantee a single-row scan (due to uniqueness).
EXPLAIN SELECT * FROM t2 WHERE v1 = 1 and v2 = 1 and v3 = 1;
                                QUERY PLAN
--------------------------------------------------------------------------
 Index Scan using t2_v3_uniq_idx on t2  (cost=0.00..4.13 rows=1 width=20)
   Index Cond: (v3 = 1)
   Filter: ((v1 = 1) AND (v2 = 1))
(3 rows)

-- Expect to use t2_v1_v2_idx because condition partly matches.
EXPLAIN SELECT * FROM t2 WHERE v1 >= 1 and v2 > 1;
                               QUERY PLAN
-------------------------------------------------------------------------
 Index Scan using t2_v1_v2_idx on t2  (cost=0.00..5.25 rows=10 width=20)
   Index Cond: ((v1 >= 1) AND (v2 > 1))
(2 rows)

--------------------------------------
-- Test covered vs uncovered indexes.
-- Should prioritize the pkey index because it covers all columns (index only scan).
EXPLAIN SELECT * FROM t2 WHERE h = 1 and v1 = 1;
                              QUERY PLAN
----------------------------------------------------------------------
 Index Scan using t2_pkey on t2  (cost=0.00..15.75 rows=100 width=20)
   Index Cond: (h = 1)
   Filter: (v1 = 1)
(3 rows)

EXPLAIN SELECT * FROM t2 WHERE h = 1 and r = 2 and v1 = 1 and v2 = 2;
                            QUERY PLAN
-------------------------------------------------------------------
 Index Scan using t2_pkey on t2  (cost=0.00..4.12 rows=1 width=20)
   Index Cond: ((h = 1) AND (r = 2))
   Filter: ((v1 = 1) AND (v2 = 2))
(3 rows)

-- Should prioritize the t1_v1_v2_idx because it is fully specified.
EXPLAIN SELECT * FROM t2 WHERE h = 1 and v1 = 1 and v2 = 2;
                               QUERY PLAN
-------------------------------------------------------------------------
 Index Scan using t2_v1_v2_idx on t2  (cost=0.00..5.30 rows=10 width=20)
   Index Cond: ((v1 = 1) AND (v2 = 2))
   Filter: (h = 1)
(3 rows)

--------------------------------------
-- Test partial indexes.
DROP INDEX t2_v3_uniq_idx;
-- Should use t1_v1_v2_idx because conditions partly match.
EXPLAIN SELECT * FROM t2 WHERE v1 = 1 AND v3 > 1;
                                QUERY PLAN
---------------------------------------------------------------------------
 Index Scan using t2_v1_v2_idx on t2  (cost=0.00..16.75 rows=100 width=20)
   Index Cond: (v1 = 1)
   Filter: (v3 > 1)
(3 rows)

EXPLAIN SELECT * FROM t2 WHERE v1 = 1 AND v3 > 2;
                                QUERY PLAN
---------------------------------------------------------------------------
 Index Scan using t2_v1_v2_idx on t2  (cost=0.00..16.75 rows=100 width=20)
   Index Cond: (v1 = 1)
   Filter: (v3 > 2)
(3 rows)

EXPLAIN SELECT * FROM t2 WHERE v1 = 1 AND v3 > 3;
                                QUERY PLAN
---------------------------------------------------------------------------
 Index Scan using t2_v1_v2_idx on t2  (cost=0.00..16.75 rows=100 width=20)
   Index Cond: (v1 = 1)
   Filter: (v3 > 3)
(3 rows)

CREATE INDEX t2_v1_v2_uniq_partial_idx ON t2(v1, v2) WHERE v3 > 2;
-- Should still use t1_v1_v2_idx because partial index condition does not match.
EXPLAIN SELECT * FROM t2 WHERE v1 = 1 AND v3 > 1;
                                QUERY PLAN
---------------------------------------------------------------------------
 Index Scan using t2_v1_v2_idx on t2  (cost=0.00..16.75 rows=100 width=20)
   Index Cond: (v1 = 1)
   Filter: (v3 > 1)
(3 rows)

-- Should both use t1_v1_v2_uniq_partial_idx.
EXPLAIN SELECT * FROM t2 WHERE v1 = 1 AND v3 > 2;
                                       QUERY PLAN
----------------------------------------------------------------------------------------
 Index Scan using t2_v1_v2_uniq_partial_idx on t2  (cost=0.00..14.00 rows=100 width=20)
   Index Cond: (v1 = 1)
(2 rows)

EXPLAIN SELECT * FROM t2 WHERE v1 = 1 AND v3 > 3;
                                       QUERY PLAN
----------------------------------------------------------------------------------------
 Index Scan using t2_v1_v2_uniq_partial_idx on t2  (cost=0.00..14.20 rows=100 width=20)
   Index Cond: (v1 = 1)
   Filter: (v3 > 3)
(3 rows)

--------------------------------------
-- Backwards vs forward scans.
--------------------------------------
CREATE TABLE t3(k int primary key, v1 int, v2 int);
CREATE INDEX asc_idx on t3(v1 HASH, v2 ASC);
CREATE INDEX desc_idx on t3(v1 HASH, v2 DESC);
-- Should use asc index.
EXPLAIN SELECT * FROM t3 WHERE v1 = 1 ORDER BY v2 ASC;
                              QUERY PLAN
----------------------------------------------------------------------
 Index Scan using asc_idx on t3  (cost=0.00..16.25 rows=100 width=12)
   Index Cond: (v1 = 1)
(2 rows)

EXPLAIN SELECT * FROM t3 WHERE v1 = 1 AND v2 > 3 ORDER BY v2 ASC;
                             QUERY PLAN
--------------------------------------------------------------------
 Index Scan using asc_idx on t3  (cost=0.00..5.25 rows=10 width=12)
   Index Cond: ((v1 = 1) AND (v2 > 3))
(2 rows)

EXPLAIN SELECT * FROM t3 WHERE v1 = 1 AND v2 <= 3 ORDER BY v2 ASC;
                             QUERY PLAN
--------------------------------------------------------------------
 Index Scan using asc_idx on t3  (cost=0.00..5.25 rows=10 width=12)
   Index Cond: ((v1 = 1) AND (v2 <= 3))
(2 rows)

-- Should use desc index.
EXPLAIN SELECT * FROM t3 WHERE v1 = 1 ORDER BY v2 DESC;
                              QUERY PLAN
-----------------------------------------------------------------------
 Index Scan using desc_idx on t3  (cost=0.00..16.25 rows=100 width=12)
   Index Cond: (v1 = 1)
(2 rows)

EXPLAIN SELECT * FROM t3 WHERE v1 = 1 AND v2 > 3 ORDER BY v2 DESC;
                             QUERY PLAN
---------------------------------------------------------------------
 Index Scan using desc_idx on t3  (cost=0.00..5.25 rows=10 width=12)
   Index Cond: ((v1 = 1) AND (v2 > 3))
(2 rows)

EXPLAIN SELECT * FROM t3 WHERE v1 = 1 AND v2 <= 3 ORDER BY v2 DESC;
                             QUERY PLAN
---------------------------------------------------------------------
 Index Scan using desc_idx on t3  (cost=0.00..5.25 rows=10 width=12)
   Index Cond: ((v1 = 1) AND (v2 <= 3))
(2 rows)

DROP TABLE t1;
DROP TABLE t2;
DROP TABLE t3;
